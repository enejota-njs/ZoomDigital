<h1 align="center"> 
 Zoom Digital: Redimensionamento de Imagens com FPGA em Verilog
</h1>

---

## üß© Descri√ß√£o do Projeto

O projeto tem como objetivo criar um **m√≥dulo embarcado** para **redimensionar imagens em tempo real**, rodando **inteiramente em FPGA**.  
Ele funciona como um **co-processador gr√°fico** capaz de fazer **zoom (aproxima√ß√£o)** e **redu√ß√£o** direto no hardware, simulando uma interpola√ß√£o visual simples.  

Todo o controle √© feito pelos **bot√µes da placa**, e a imagem processada aparece em um **monitor VGA**, sem depender de processadores externos ‚Äî ou seja, o sistema √© **totalmente aut√¥nomo**.  

---

## ‚öôÔ∏è Especifica√ß√µes

- **üß† Linguagem:** Verilog  
- **üíª Kit de desenvolvimento:** DE1-SoC  
- **üé® Tipo de imagem:** Escala de cinza (8 bits por pixel)  
- **üîß Opera√ß√µes implementadas:**
  - **Zoom In (Aproxima√ß√£o):**
    - Vizinho Mais Pr√≥ximo (Nearest Neighbor)
    - Replica√ß√£o de Pixel (Pixel Replication)
  - **Zoom Out (Redu√ß√£o):**
    - Decima√ß√£o / Amostragem simples (Nearest Neighbor para Zoom Out)
    - M√©dia de Blocos (Block Averaging)
- **üéõÔ∏è Controle:** Bot√µes f√≠sicos da FPGA  
- **üñ•Ô∏è Sa√≠da de v√≠deo:** VGA  
- **üîó Compatibilidade:** Funciona como **coprocessador** para o processador **ARM (HPS)**  

---

## üß∞ Ambiente de Desenvolvimento

O c√≥digo foi desenvolvido no **Quartus Prime**, que oferece tudo o que √© preciso para criar e testar projetos em FPGA ‚Äî desde a **edi√ß√£o e compila√ß√£o** at√© a **s√≠ntese e simula√ß√£o**.  

Esse ambiente tamb√©m permite **configurar os pinos**, realizar **testes funcionais e temporais**, e validar o projeto antes da implementa√ß√£o na **placa DE1-SoC**.  

- **üß© Software utilizado:** Quartus Prime  
- **üì¶ Vers√£o:** 23.1  
- **üîç Funcionalidades principais:**
  - Edi√ß√£o e compila√ß√£o de projetos em Verilog  
  - S√≠ntese para FPGA  
  - Configura√ß√£o de pinos  
  - Simula√ß√£o funcional e temporal  
  - Valida√ß√£o do projeto antes da implementa√ß√£o f√≠sica  

---

## üì¶ Guia de Instala√ß√£o e Uso do Quartus com Projeto do GitHub

### 1. Baixar e instalar o Quartus

1. Acesse o site oficial da Intel FPGA: [https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html](https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html)  
2. Escolha a vers√£o **Quartus Prime Lite 23.1** (Lite √© gratuita).  
3. Fa√ßa o download do instalador compat√≠vel com seu sistema operacional (Windows ou Linux).  
4. Execute o instalador e siga os passos:  
   - Aceite o contrato de licen√ßa.  
   - Escolha o caminho de instala√ß√£o.  
   - Marque os pacotes que deseja instalar (Quartus, ModelSim).  
6. Finalize a instala√ß√£o e abra o **Quartus Prime**.

### 2. Baixar o projeto do GitHub

1. Acesse o reposit√≥rio no GitHub.  
2. Clique no bot√£o **Code ‚Üí Download ZIP**.  
3. Salve o arquivo `.zip` em uma pasta de sua prefer√™ncia.  
4. Extraia o conte√∫do do arquivo `.zip` (clicar com o bot√£o direito ‚Üí Extrair aqui ou usar um descompactador).

### 3. Abrir o projeto no Quartus

1. Abra o Quartus Prime.  
2. Clique em **File ‚Üí Open Project‚Ä¶**  
3. Navegue at√© a pasta descompactada do projeto.  
4. Selecione o arquivo de projeto do Quartus (`.qpf`) e clique em **Open**.  
5. Certifique-se de que todos os arquivos do projeto aparecem na **Project Navigator**.

### 4. Compilar o projeto

1. No Quartus, clique em **Processing ‚Üí Start Compilation** (ou pressione **Ctrl+L**).  
2. Aguarde a compila√ß√£o completa.  
3. Verifique se n√£o h√° erros na **Mensagem de Compila√ß√£o**.  

### 5. Programar a placa

1. Conecte sua placa DE1-SoC ao computador via cabo USB-Blaster.  
2. No Quartus, abra o **Programmer**: **Tools ‚Üí Programmer**.  
3. Clique em **Hardware Setup** e selecione o seu **USB-Blaster**.  
4. Clique em **Add File** e selecione o arquivo `.sof` gerado na compila√ß√£o.  
5. Certifique-se de que a op√ß√£o **Program/Configure** esteja marcada.  
6. Clique em **Start** para enviar o projeto para a placa.  
7. Aguarde a mensagem de **Success**, indicando que a programa√ß√£o foi conclu√≠da.

---

## Kit de desenvolvimento

![FPGA](Imagens/Imagem%20da%20FPGA.jpg)

O Kit de Desenvolvimento **DE1-SoC** apresenta uma plataforma de hardware robusta constru√≠da em torno do FPGA Altera System-on-Chip (SoC), que combina os mais recentes n√∫cleos embarcados **Cortex-A9 dual-core** com l√≥gica program√°vel de ponta, oferecendo m√°xima flexibilidade de projeto. Os usu√°rios podem aproveitar a grande reconfigurabilidade junto a um sistema de processador de alto desempenho e baixo consumo de energia. O SoC da Altera integra um sistema de processador hard baseado em ARM (**HPS**), composto por processador, perif√©ricos e interfaces de mem√≥ria, ligados de forma transparente √† estrutura FPGA por meio de um interconector de alta largura de banda. A placa de desenvolvimento DE1-SoC vem equipada com mem√≥ria **DDR3** de alta velocidade, recursos de v√≠deo e √°udio, conectividade **Ethernet**, entre outros, oferecendo diversas aplica√ß√µes potenciais e inovadoras.

--- 

## üõ† FPGA

- ‚ö° **Dispositivo:** Altera Cyclone¬Æ V SE 5CSEMA5F31C6N  
- üíæ **Dispositivo de configura√ß√£o serial:** Altera EPCS128  
- üîå **Programa√ß√£o:** USB-Blaster II onboard para programa√ß√£o; Modo JTAG (Tamb√©m suporta RISC-V JTAG)  
- üîò **Bot√µes:** 4 push-buttons  
- ‚è± **Fontes de clock:** Quatro clocks de 50 MHz do gerador de clock  
- üé® **VGA:** DAC VGA (DACs triplos de alta velocidade de 8 bits) com conector VGA-out  
- üîß **Elementos l√≥gicos program√°veis:** 85K  
- üß† **Mem√≥ria embutida:** 4.450 Kbits

---

## Algoritmos

### Aproxima√ß√£o (Zoom in)

<p align="justify">
A aproxima√ß√£o digital, tamb√©m conhecida como zoom in, √© o processo de amplia√ß√£o de uma imagem atrav√©s do aumento do n√∫mero de pixels. Este processo √© fundamental em sistemas de processamento digital de imagens, especialmente em aplica√ß√µes que requerem an√°lise detalhada de regi√µes espec√≠ficas. Os algoritmos de aproxima√ß√£o implementados neste projeto focam na efici√™ncia computacional para execu√ß√£o em hardware FPGA, garantindo processamento em tempo real.
</p>

---

### Vizinho Mais Pr√≥ximo (Nearest Neighbor Interpolation)

A **Interpola√ß√£o por Vizinho Mais Pr√≥ximo** √© o m√©todo mais simples e fundamental de amplia√ß√£o de imagens digitais . Esta t√©cnica √© amplamente utilizada em sistemas embarcados devido √† sua **simplicidade computacional** e **velocidade de processamento**.

---

#### ‚öôÔ∏è Como Funciona

1.  **Princ√≠pio B√°sico:**
    Para cada novo pixel na imagem ampliada, o algoritmo determina qual pixel da imagem original est√° mais pr√≥ximo geometricamente.

2.  **Processo Passo a Passo:**
    * Calcula-se a posi√ß√£o correspondente na imagem original para cada pixel da nova imagem 
    * Encontra-se o pixel mais pr√≥ximo atrav√©s do **arredondamento das coordenadas**
    * O valor de intensidade do pixel mais pr√≥ximo √© **copiado diretamente**

3.  **C√°lculo das Coordenadas:**

    Para uma amplia√ß√£o com fator de zoom **n**, as coordenadas s√£o mapeadas por:

$$x_{original} = \frac{x_{novo}}{n}, \quad y_{original} = \frac{y_{novo}}{n}$$

#### üìå Exemplo Pr√°tico

Se uma imagem tem 100x100 pixels e aplica-se um **fator de zoom** n = 2, a nova imagem ter√°:

üëâ 200x200 pixels.

#### üî¨ Exemplo Visual

![Vizinho Mais Pr√≥ximo](Imagens/Vizinho%20Mais%20Pr√≥ximo.gif)

A imagem acima ilustra a aplica√ß√£o do algoritmo de vizinho mais pr√≥ximo. O fator de zoom est√° indicado no canto superior esquerdo da imagem. Cada pixel da regi√£o superior esquerda √© duplicado de acordo com o fator de zoom, formando uma imagem ampliada, onde cada novo pixel assume o valor do pixel mais pr√≥ximo da imagem original.

Para um pixel na posi√ß√£o (150, 120) da imagem ampliada:
- Coordenada original: (75.0, 60.0)
- Vizinho mais pr√≥ximo: (75, 60)
- Valor copiado: intensidade do pixel (75, 60)

#### üî¨ Caracter√≠sticas do Algoritmo

| Aspecto | Detalhe |
| :---: | :--- |
| **‚ö° Velocidade** | **Extremamente r√°pido:** Apenas opera√ß√µes de divis√£o e arredondamento |
| **üíæ Mem√≥ria** | **Baixo consumo:** N√£o requer armazenamento de valores intermedi√°rios |
| **üéØ Precis√£o** | **Preserva valores originais:** Nenhum pixel artificial √© criado |

---

#### üéØ Vantagens e Desvantagens

| Categoria | Detalhe |
| :---: | :--- |
| **üü¢ Vantagem** | **Simplicidade Extrema:** Implementa√ß√£o direta, ideal para FPGA e sistemas de tempo real. Preserva perfeitamente os valores de pixel originais. |
| **üü¢ Vantagem** | **Efici√™ncia:** Requer apenas opera√ß√µes b√°sicas de aritm√©tica inteira, sem multiplica√ß√µes complexas ou c√°lculos de m√©dia. |
| **üî¥ Desvantagem** | **Efeito Escada:** Produz bordas serrilhadas (*aliasing*) em linhas diagonais e curvas devido ao arredondamento discreto. |
| **üî¥ Desvantagem** | **Perda de Suavidade:** A imagem resultante pode parecer pixelizada, especialmente em amplia√ß√µes grandes. |

#### üß© Aplica√ß√µes Ideais

**Perfeito para:**
- Sistemas embarcados com recursos limitados.
- Processamento de imagens em tempo real.
- Amplia√ß√£o de *pixel art* e gr√°ficos de jogos retr√¥.
- Aplica√ß√µes onde a **velocidade** √© mais importante que a **qualidade visual**.

---

### üñºÔ∏è Replica√ß√£o de Pixel (Pixel Replication)

A **Replica√ß√£o de Pixel**, tamb√©m conhecida como **Pixel Replication**, √© uma das t√©cnicas mais simples e cl√°ssicas de amplia√ß√£o de imagens digitais. Apesar da sua simplicidade, √© muito utilizada em contextos onde a **velocidade** √© mais importante do que a **qualidade visual**.

#### ‚öôÔ∏è Como Funciona

1.  **Princ√≠pio B√°sico:**
    O objetivo √© aumentar o n√∫mero total de *pixels* (ou *amostras*) da imagem original.

2.  **Processo Passo a Passo:**
    * Cada *pixel* da imagem original √© **replicado** (copiado) v√°rias vezes.
    * O n√∫mero de c√≥pias depende do **fator de zoom** (n)
    * O pixel mant√©m exatamente a **mesma cor** e **valor de intensidade**.

3.  **C√°lculo do Novo Tamanho:**

    A nova dimens√£o √© dada por:

$$\text{Nova Dimens√£o} = (\text{Linhas Originais} \times n, \ \text{Colunas Originais} \times n)$$

#### üìå Exemplo Pr√°tico

Se uma imagem tem 100x100 pixels e aplica-se um **fator de zoom** n = 3, a nova imagem ter√°:

üëâ 300x300 pixels.

#### üî¨ Exemplo Visual

![Replica√ß√£o de Pixel](Imagens/Replica√ß√£o%20de%20Pixel.gif)

A imagem acima ilustra a aplica√ß√£o do algoritmo de replica√ß√£o de pixels. O fator de zoom est√° indicado no canto superior esquerdo da imagem. Cada pixel do bloco 2x2 superior esquerdo √© replicado para formar um novo bloco 2x2, resultando em uma imagem do mesmo tamanho da original, por√©m com o zoom aplicado.

#### üéØ Vantagens e Desvantagens

| Categoria | Detalhe |
| :---: | :--- |
| **üü¢ Vantagem** | **Extrema Simplicidade:** Implementa√ß√£o direta, sem c√°lculos complexos nem interpola√ß√£o. Ideal para aplica√ß√µes em tempo real ou dispositivos com baixo poder de processamento. |
| **üî¥ Desvantagem** | **Perda de Qualidade:** A imagem resultante apresenta um aspeto **pixelizado** e **borrado** (*blurry*), especialmente vis√≠vel em imagens fotogr√°ficas. |
| **üß© Melhor Uso** | Muito usada em jogos retr√¥, *pixel art*, ou visualiza√ß√µes r√°pidas onde o estilo "quadrado" √© desejado. |

---

### Redu√ß√£o (Zoom Out)

A redu√ß√£o digital, tamb√©m conhecida como zoom out, √© o processo de diminui√ß√£o do tamanho de uma imagem por meio da redu√ß√£o do n√∫mero de pixels exibidos. Esse procedimento tem como principal objetivo representar a mesma informa√ß√£o visual de forma mais compacta, mantendo a coer√™ncia estrutural da imagem original.

---

### üü• Decima√ß√£o / Amostragem (Nearest Neighbor for Zoom Out)

O **algoritmo de Decima√ß√£o** √© uma t√©cnica simples de **redu√ß√£o de imagens**, utilizada quando o objetivo √© diminuir o tamanho da imagem de forma r√°pida, mesmo que isso implique em perda de detalhes. √â eficiente para contextos onde a **velocidade** √© mais importante do que a **precis√£o visual**.

#### ‚öôÔ∏è Como Funciona

1.  **Princ√≠pio B√°sico:**
    Reduzir a imagem selecionando apenas alguns pixels representativos e descartando os demais.

2.  **Processo Passo a Passo:**
    * Divida a imagem em blocos de tamanho `2x2`.  
    * Para cada bloco, selecione **apenas o pixel superior esquerdo**.  
    * Alocar esse pixel no centro do bloco correspondente na nova imagem.  
    * Descartar os outros 3 pixels.  

3.  **C√°lculo do Novo Tamanho:**

    A nova dimens√£o √© dada por:

$$\text{Nova Dimens√£o} = \frac{\text{Linhas Originais}}{2}, \ \frac{\text{Colunas Originais}}{2}$$

#### üìå Exemplo Pr√°tico

Se uma imagem tem 100x100 pixels e aplica-se a decima√ß√£o com blocos de `2x2`, a nova imagem ter√°:

üëâ 50x50 pixels.

#### üî¨ Exemplo Visual

![Decima√ß√£o](Imagens/Decima√ß√£o.gif)

A imagem acima ilustra a aplica√ß√£o do algoritmo de decima√ß√£o. A cada bloco de 2x2 pixels, o pixel superior esquerdo √© selecionado e alocado no centro do bloco correspondente na nova imagem, enquanto os outros tr√™s pixels s√£o descartados. Esse processo √© repetido para todos os blocos, resultando em uma vers√£o reduzida da imagem original.

#### üéØ Vantagens e Desvantagens

| Categoria | Detalhe |
| :---: | :--- |
| **üü¢ Vantagem** | **Simplicidade e Velocidade:** Implementa√ß√£o direta, ideal para redu√ß√£o r√°pida de imagens e processamento em tempo real. |
| **üî¥ Desvantagem** | **Perda de Detalhes:** Muitos pixels s√£o descartados, podendo resultar em imagens borradas ou com informa√ß√µes ausentes. |
| **üß© Melhor Uso** | Redu√ß√£o r√°pida de imagens, pr√©-processamento para compress√£o ou aplica√ß√µes onde tamanho e velocidade s√£o mais importantes que fidelidade visual. |

---

### üü¶ M√©dia de Blocos (Block Averaging / Downsampling with Averaging)

A **M√©dia de Blocos** √© uma t√©cnica de redu√ß√£o de imagens digitais que visa diminuir o tamanho da imagem de forma uniforme, calculando a m√©dia dos pixels em blocos. √â um m√©todo simples e eficaz para criar uma vers√£o menor da imagem mantendo a suavidade visual.

#### ‚öôÔ∏è **Como Funciona**  
**Princ√≠pio B√°sico:** Cada bloco de n pixels da imagem original √© substitu√≠do por um √∫nico valor que representa a m√©dia de intensidade ou cor de todos os pixels do bloco.

**Processo Passo a Passo:**

1. Divida a imagem em blocos de tamanho `n x n`.  
2. Para cada bloco, calcule a m√©dia de todos os pixels (valores de cor ou intensidade).  
3. Substitua um determinado pixel pelo valor m√©dio.  
4. Repita o processo para todos os blocos da imagem, formando a imagem reduzida.

**C√°lculo do Novo Tamanho:**  

- A nova dimens√£o √© dada por:  

\[
\text{Nova Dimens√£o} = \frac{\text{Linhas Originais}}{n} , \frac{\text{Colunas Originais}}{n}
\]

#### üìå **Exemplo Pr√°tico**  
Se uma imagem tem 100x100 pixels e se aplica blocos de `2x2` para redu√ß√£o:  

üëâ A nova imagem ter√° 50x50 pixels.

#### üî¨ Exemplo Visual

![M√©dia de Blocos](Imagens/M√©dia%20de%20Blocos.gif)

A imagem acima ilustra a aplica√ß√£o do algoritmo de M√©dia de Blocos. A cada bloco de 2x2 pixels, √© calculada a m√©dia dos valores de intensidade ou cor, e esse valor √© alocado no centro do bloco correspondente na nova imagem reduzida. Esse processo √© repetido para todos os blocos, resultando em uma vers√£o menor da imagem original, mantendo a suavidade visual.

#### üéØ **Vantagens e Desvantagens**  

| Categoria | Detalhe |
|-----------|---------|
| üü¢ **Vantagem** | Redu√ß√£o eficiente de tamanho mantendo suavidade; menos ru√≠do. |
| üî¥ **Desvantagem** | Perda de detalhes finos; bordas podem ficar borradas. |
| üß© **Melhor Uso** | Ideal para redu√ß√£o de imagens, pr√©-processamento para compress√£o ou visualiza√ß√µes r√°pidas. |

---

## Caminho de Dados

![Caminho de Dados](Imagens/Caminho%20de%20Dados.png)

üîó [Ver em alta qualidade](https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&target=blank&highlight=000000&layers=1&nav=1&title=Caminho%20de%20Dados.drawio&dark=auto#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D16_pdd4TADHBSyZAoE4eO0e6Gq3GJ_Lt0%26export%3Ddownload)

## üß† Arquitetura do Sistema de Processamento de Imagens FPGA

Este projeto implementa uma arquitetura completa para **processamento digital de imagens em FPGA**, com suporte a m√∫ltiplos algoritmos e exibi√ß√£o em **VGA**.  
A coordena√ß√£o geral √© feita pelo m√≥dulo `control_unit`, que gerencia os sinais de controle, endere√ßos e dados entre os m√≥dulos e as mem√≥rias.

---

### üî∑ Vis√£o Geral

O sistema permite a execu√ß√£o dos seguintes algoritmos de forma independente:

- üîÅ **Pixel Replication** ‚Äì Zoom in por duplica√ß√£o de pixels.  
- üîª **Pixel Decimation** ‚Äì Redu√ß√£o de resolu√ß√£o (zoom out).  
- ‚öñÔ∏è **Block Averaging** ‚Äì Suaviza√ß√£o por m√©dia de blocos 2√ó2.  
- üî≤ **Nearest Neighbor Interpolation** ‚Äì Interpola√ß√£o por vizinho mais pr√≥ximo.

Cada opera√ß√£o √© iniciada por um sinal de **start** espec√≠fico e processada com base nos dados da mem√≥ria prim√°ria.

---

## üß© Estrutura do Sistema

### üïπÔ∏è CONTROL ‚Äì Unidade de Controle Principal

- Gerencia todos os m√≥dulos de processamento.  
- Recebe os sinais `START_REPL`, `START_DEC`, `START_AVG` e `START_NN`.  
- Garante que apenas **um algoritmo** seja executado por vez, evitando conflitos entre m√≥dulos.  
- Controla o fluxo de dados entre a **mem√≥ria prim√°ria**, a **mem√≥ria secund√°ria** e o m√≥dulo **VGA**, coordenando as leituras e escritas durante o processamento.  
- Define o **modo de exibi√ß√£o**:  
  - `320x240` ‚Üí imagem original ou ampliada (zoom in)  
  - `160x120` ‚Üí imagem reduzida (zoom out)  
- Tamb√©m √© respons√°vel por **sincronizar a atualiza√ß√£o da imagem na sa√≠da VGA** conforme o algoritmo selecionado.

### üéõÔ∏è Controle por Bot√µes F√≠sicos (KEYs)

O acionamento dos algoritmos √© feito por meio dos **bot√µes f√≠sicos (KEYs)** presentes na placa DE1-SoC. Cada bot√£o inicia a execu√ß√£o de um m√≥dulo de processamento espec√≠fico:

| Bot√£o | Fun√ß√£o | Algoritmo Ativado |
| :---: | :---: | :--- |
| **KEY0** | üîÅ | **Replica√ß√£o de Pixel (Pixel Replication)** |
| **KEY1** | üî≤ | **Vizinho Mais Pr√≥ximo (Nearest Neighbor)** |
| **KEY2** | üîª | **Decima√ß√£o (Pixel Decimation)** |
| **KEY3** | ‚öñÔ∏è | **M√©dia de Blocos (Block Averaging)** |

Ao pressionar um dos bot√µes, o sistema envia o sinal correspondente de `START`, ativando o m√≥dulo de processamento apropriado.  
Quando um novo algoritmo √© selecionado, o sistema **restaura automaticamente a imagem original** antes de aplicar o pr√≥ximo processamento, garantindo que cada resultado seja independente e livre de interfer√™ncias de execu√ß√µes anteriores.

---

### ‚öôÔ∏è M√≥dulos de Processamento

#### üîÅ Pixel Replication
- Duplica cada pixel para gerar uma imagem ampliada.  
- Cria novos endere√ßos de escrita e dados replicados.  
- Utilizado para **zoom in**.

#### üîª Pixel Decimation
- Reduz a resolu√ß√£o da imagem descartando pixels em intervalos regulares.  
- Ideal para **zoom out**.

#### ‚öñÔ∏è Block Averaging
- Calcula a m√©dia de blocos 2√ó2 de pixels.  
- Reduz ru√≠dos e suaviza transi√ß√µes.  
- Usa dois m√≥dulos auxiliares:  
  - `address_counter_avg`: gera endere√ßos de leitura.  
  - `block_average`: calcula a m√©dia de quatro valores.

#### üî≤ Nearest Neighbor Interpolation
- Redimensiona a imagem utilizando o m√©todo do **vizinho mais pr√≥ximo**.  
- Mant√©m bordas n√≠tidas e processamento r√°pido.

---

### üì¶ COPY COUNTER

- Respons√°vel pela **c√≥pia inicial** da imagem da mem√≥ria prim√°ria para a secund√°ria.  
- Tamb√©m restaura a imagem base antes de aplicar um novo algoritmo.

---

### üîÄ MUX ‚Äì Multiplexadores

- Selecionam quais sinais (endere√ßos, dados e enable de escrita) s√£o enviados √† **mem√≥ria secund√°ria**.  
- Alteram dinamicamente conforme o algoritmo ativo.

---

### üíæ Mem√≥rias

#### üìò Primary Memory
- Armazena a **imagem original**.  
- Somente leitura durante o processamento.

#### üìô Secondary Memory
- Armazena o **resultado processado**.  
- √â constantemente sobrescrita pelos m√≥dulos ativos.

---

### üñ•Ô∏è Sistema VGA

#### üéõÔ∏è VGA Controller
- L√™ os pixels da **mem√≥ria secund√°ria**.  
- Gera sinais de cor (`R`, `G`, `B`) e endere√ßos de leitura.  
- Suporta os modos 320√ó240 e 160√ó120.

#### üí° VGA Output / Driver
- Converte os sinais em formato compat√≠vel com monitores VGA.  
- Gera `hsync`, `vsync`, `blank`, `sync` e `clk`.

---

### üîÑ Fluxo de Dados

1. O controle inicia a c√≥pia da imagem base.  
2. Um algoritmo √© ativado por um sinal de start.  
3. O m√≥dulo correspondente l√™ da **mem√≥ria prim√°ria** e escreve na **mem√≥ria secund√°ria**.  
4. O controlador VGA exibe o resultado em tempo real.  
5. Se outro algoritmo for selecionado, o sistema restaura a imagem original antes de aplicar o novo processamento.

---

## üß™ Testes e Resultados

### üîÅ Imagem original

![Imagem original](Imagens/Imagem%20Original.jpg)

---

### üîÅ Aplica√ß√£o do algoritmo Pixel Replication

![GIF Pixel Replica√ß√£o](Imagens/GIF%20Replica√ß√£o%20de%20Pixel.gif)

---

### üîª Aplica√ß√£o do algoritmo Pixel Decimation

![GIF Decima√ß√£o](Imagens/GIF%20Decima√ß√£o.gif)

---

### ‚öñÔ∏è Aplica√ß√£o do algoritmo Block Averaging

![GIF M√©dia de Blocos](Imagens/GIF%20M√©dia%20de%20Blocos.gif)

---

### üî≤ Aplica√ß√£o do algoritmo Nearest Neighbor Interpolation

![GIF Vizinho Mais Pr√≥ximo](Imagens/GIF%20Vizinho%20Mais%20Pr√≥ximo.gif)

---

## ‚úÖ Conclus√£o

O projeto de **Zoom Digital em FPGA** demonstrou com sucesso a implementa√ß√£o de algoritmos de **amplia√ß√£o e redu√ß√£o de imagens** em tempo real, totalmente executados no hardware da placa DE1-SoC. A partir dos testes realizados, foi poss√≠vel observar que:

- O **Pixel Replication** proporciona uma amplia√ß√£o r√°pida, preservando os valores originais, por√©m com efeito pixelizado percept√≠vel.  
- O **Nearest Neighbor** mant√©m bordas n√≠tidas e √© eficiente em termos de processamento, sendo ideal para aplica√ß√µes que priorizam velocidade.  
- A **Decima√ß√£o** permite redu√ß√£o eficiente do tamanho da imagem, mas implica em perda de detalhes finos.  
- A **M√©dia de Blocos** reduz ru√≠dos e suaviza transi√ß√µes, gerando imagens menores com melhor apar√™ncia visual, embora com ligeira perda de nitidez.

O sistema desenvolvido mostrou-se **robusto e aut√¥nomo**, utilizando apenas a FPGA e a mem√≥ria da placa, sem depender de processadores externos. Os resultados confirmam que cada algoritmo possui caracter√≠sticas espec√≠ficas de desempenho e qualidade visual, permitindo selecionar o m√©todo mais adequado conforme a aplica√ß√£o desejada.

Em suma, o projeto valida a **viabilidade do processamento de imagens em tempo real em FPGA**, combinando efici√™ncia, flexibilidade e autonomia, servindo como uma base s√≥lida para futuras aplica√ß√µes em sistemas embarcados e processamento gr√°fico direto no hardware.

---

## üñ•Ô∏è Contribuidores

[<img src="https://github.com/FelipeBastosz.png" width="80" height="80">](https://github.com/FelipeBastosz)     [<img src="https://github.com/limajonatas.png" width="80" height="80">](https://github.com/limajonatas)     [<img src="https://github.com/enejota-njs.png" width="80" height="80">](https://github.com/enejota-njs) 

---

## üìö Refer√™ncias

**Digital Image Processing - Zooming Methods** - Tutorialspoint. Dispon√≠vel em: <a href="https://www.tutorialspoint.com/dip/zooming_methods.htm" target="_blank">https://www.tutorialspoint.com/dip/zooming_methods.htm</a>

**Digital image processing** - Wikipedia. Dispon√≠vel em: <a href="https://en.wikipedia.org/wiki/Digital_image_processing" target="_blank">https://en.wikipedia.org/wiki/Digital_image_processing</a>

**Interpola√ß√£o por vizinho mais pr√≥ximo** - Wikipedia. Dispon√≠vel em: <a href="https://pt.wikipedia.org/wiki/Interpola√ß√£o_por_vizinho_mais_pr√≥ximo" target="_blank">https://pt.wikipedia.org/wiki/Interpola√ß√£o_por_vizinho_mais_pr√≥ximo</a>

**Wojcicki, K.** (2020). *Nearest Neighbour Interpolation Theory*. Dispon√≠vel em: <a href="https://kwojcicki.github.io/blog/NEAREST-NEIGHBOUR" target="_blank">https://kwojcicki.github.io/blog/NEAREST-NEIGHBOUR</a>

**Digital Image Processing - Zooming Methods** - Tutorialspoint. Dispon√≠vel em: <a href="https://www.tutorialspoint.com/dip/zooming_methods.htm" target="_blank">https://www.tutorialspoint.com/dip/zooming_methods.htm</a>

**Nearest-neighbor interpolation** - Wikipedia. Dispon√≠vel em: <a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation" target="_blank">https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation</a>

**Centeno, M.** *Processamento digital de imagens - Interpola√ß√£o*. UFPR. Dispon√≠vel em: <a href="https://docs.ufpr.br/~centeno/m_pdi/pdf/jaulapdi05.pdf" target="_blank">https://docs.ufpr.br/~centeno/m_pdi/pdf/jaulapdi05.pdf</a>

**Nearest Neighbour Interpolation - Image Processing** - Giassa. Dispon√≠vel em: <a href="https://www.giassa.net/?page_id=207" target="_blank">https://www.giassa.net/?page_id=207</a>

* **Conceitos de Zooming e Reamostragem:** [Tutorialspoint - Zooming Methods](https://www.tutorialspoint.com/dip/zooming_methods.htm)
